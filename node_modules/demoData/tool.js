var tool = function () {
    this.primaryKeyColumn = '_pkid';
    this.parentIdColumn = '_parentId';
    this.path = require('path');
    this.fs = require('fs');
    this.projectConfig = require('../common/getConfig');
};

tool.prototype = {
    /*拼接表名称*/
    createTableName: function (prevNodeName, currNodename) {
        return prevNodeName + '_' + currNodename;
    },
    /*拼接子表和主表的关系列名称*/
    createChildTableForeignColumnName: function (parentTableName) {
        return '_' + parentTableName + 'Id';
    },
    /*解析数据结果*/
    parseResult: function (result, fn, demoDataObj) {
        var _this = this;
        var root = _mapConfig[fn];
        if (!root) return false;
        var dataTypeObj = pconst.mapDataType;
        result = (_this.projectConfig.isRealData == true ? result : demoDataObj[fn]) || [];
        var proArr = root.proArr || _mapConfig[root.proArrBy] || [];
        var sendResult = parse(root, result, fn);
        return sendResult;

        function parse(node, result, parentTableName, type) {
            result = result || [];
            type = type || node.type;
            if (type == dataTypeObj.tree.name) return constructorTree(result, node);
            var returnResult = [];
            var newTableName, rows, foreignColumn;
            var proArr = node.proArr || _mapConfig[node.proArrBy] || [];
            if (proArr.length == 0) {
                if (type == dataTypeObj.fileArray.name) {
                    for (var i = 0; i < result.length; i++) {
                        var rtrt = result[i];
                        result[i] = rtrt ? '/' + pconst.requestType.pdownload + '/' + psecret.create(rtrt) : '';
                    }
                }
                return result;
            }
            if (!(result instanceof Array)) result = [result];
            for (var i = 0; i < result.length; i++) {
                var currRe = result[i];
                if(currRe==null)continue;
                var tempObj = {};
                for (var j = 0; j < proArr.length; j++) {
                    var currPro = proArr[j];
                    var reValue = _this.projectConfig.isRealData == true ? currRe[currPro.mapName || currPro.name] : currRe[currPro.name];
                    var tempValue;
                    switch (currPro.type) {
                        case dataTypeObj.boolean.name:
                            tempValue = reValue == true ? true : false;
                            break;
                        case dataTypeObj.number.name:
                            tempValue = Math.toFixed({
                                value: reValue,
                                fixedNum: currPro.fixed,
                                isByInt: currPro.fixedByInt,
                                isToSpecial: currPro.isToSpecial
                            });
                            break;
                        case dataTypeObj.string.name:
                            tempValue = currPro.isToSpecial !== false ? ptool.emptyStrToHline(reValue) : reValue || '';
                            break;
                        case dataTypeObj.date.name:
                            tempValue = reValue && currPro.format ? reValue.formatDate(currPro.format) :
                                        reValue && !currPro.format ? reValue :
                                        currPro.isToSpecial !== false ? ptool.emptyStrToHline(reValue) : '';
                            break;
                        case dataTypeObj.fileLink.name:
                            tempValue = reValue ? '/' + pconst.requestType.pdownload + '/' + psecret.create(reValue) : '';
                            break;
                        case dataTypeObj.object.name:
                            if (_this.projectConfig.isRealData == true) {
                                tempValue = arguments.callee(currPro, reValue);
                                break;
                            }
                        case dataTypeObj.array.name:
                            if (_this.projectConfig.isRealData == true) {
                                tempValue = arguments.callee(currPro, reValue);
                                break;
                            }
                        case dataTypeObj.tree.name:
                            if (_this.projectConfig.isRealData == false) {
                                newTableName = _this.createTableName(parentTableName, currPro.name);
                                rows = demoDataObj[newTableName] || [];
                                foreignColumn = _this.createChildTableForeignColumnName(parentTableName);
                                reValue = rows.filter(function (a) { return a[foreignColumn] === currRe[_this.primaryKeyColumn]; });
                            }
                            tempValue = currPro.type == dataTypeObj.tree.name ? constructorTree(reValue, currPro) :
                                        arguments.callee(currPro, reValue, newTableName);
                            break;
                    }
                    tempObj[currPro.name] = tempValue;
                }
                returnResult.push(tempObj);
            }
            return type == dataTypeObj.object.name ? returnResult[0] || {} : returnResult;
        };

        function constructorTree(maxArr, currPro) {
            if (!maxArr || maxArr.length == 0) return [];
            //找寻第一级，第一级的父级id在数组内肯定不存在对应的
            var rootArr = [];
            var rootParentId;
            for (var i = 0; i < maxArr.length; i++) {
                rootArr = maxArr.filter(function (a) {
                    return _this.projectConfig.isRealData == true ? a[currPro.mapParentIdTo] == maxArr[i][currPro.mapParentId]
                        : a[_this.primaryKeyColumn] == maxArr[i][_this.parentIdColumn];
                });
                if (rootArr.length == 0) {
                    rootParentId = _this.projectConfig.isRealData == true ? maxArr[i][currPro.mapParentId] : maxArr[i][_this.parentIdColumn];
                    break;
                }
            }
            return find(rootParentId, maxArr, 1);

            //客户端需要的树，要求返回的数据必须是平铺的树
            function find(parentId, arr, level) {
                var returnArr = [];
                for (var j = 0; j < arr.length; j++) {
                    var curr = arr[j];
                    var currParentId = _this.projectConfig.isRealData == true ? curr[currPro.mapParentId] : curr[_this.parentIdColumn];
                    if (currParentId != parentId) continue;

                    var returnObj = parse(currPro, [curr], null, dataTypeObj.object.name);
                    if (!returnObj.id) returnObj.id = _this.projectConfig.isRealData == true ? curr[currPro.mapParentIdTo] : curr[_this.primaryKeyColumn];
                    if (!returnObj.parentId)
                        returnObj.parentId = _this.projectConfig.isRealData == true ? curr[currPro.mapParentId] : curr[_this.parentIdColumn];
                    returnObj.level = level;
                    //arr.splice(j, 1);
                    returnObj.child = arguments.callee(returnObj.id, arr, level + 1);
                    returnArr.push(returnObj);
                    //--j;
                }
                return returnArr;
            };
        };
    }
};

module.exports = new tool();